import copyimport reaktoro as rktimport numpy as npimport loggingfrom PlanetProfile.Utilities.defineStructs import Constantsfrom PlanetProfile.Utilities.DataManip import ResetNearestExtrapfrom scipy import interpolate# Assign loggerlog = logging.getLogger('PlanetProfile')def ConstraintFinder(P_MPa, T_K, aqueous_species_list, speciation_ratio_mol_kg):    """ Finds the constraints of pressure and temperature that are compatible with both phreeqc and supcrt databases for the given solution speciation.        Namely, the temperature lower limit will be set by supcrt as equilibrium for this database can only be found starting at temperature of ~240K.        Moreover, the upper pressure limit will be set by frezchem as equilibrium for this database can only be found at pressures as high as ~200MPa.        As of now, the temperature upper limit and pressure lower limit are not adjusted, since Reaktoro seems to be compatible with high temperatures and low pressures of        PlanetProfile so no need to adjust.        Returns adjusted pressure and temperature ranges with the found constraints. This approach is similar to MgSO4 solution, however we take advantage        of RKt's dynamic ability to find chemical equilibrium different depending on the solution, rather than hard coding in constraints.    Args:        P_MPa (shape N): Array of pressures that will be queried over in future functions, but needs to be checked to ensure the pressures are within ranges compatible with Rkt.        T_K (shape M): Array of temperatures that will be queried over in future functions, but needs to be checked to ensure the temperatures are within ranges compatible with Rkt.        aqueous_species_list: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)    Returns:        P_MPa (AT MOST shape N): Adjusted array that only has values from initial P_MPa that are compatible with RKt.        P (AT MOST shape M): Adjusted array that only has values from initial T_K that are compatible with RKt.    """    # Save the lower limit of pressure of the pressure range, which will not be adjusted since Rkt is compatible to 0.1 MPa    P_lower_MPa = P_MPa[0]    # Save the upper limit of temperature of the temperature range, which will not be adjusted since core10 and supcrt are compatible well beyond range utilized by PP    T_upper_K = T_K[np.size(T_K) - 1]    # Save the initial upper limit of pressure of the pressure range, which may be adjusted since frezchem can only go up to ~200MPa    P_initial_upper_MPa = P_MPa[np.size(P_MPa) - 1]    # If the initial upper limit is above 200 MPa (the minimum for high pressure ices), then reset to 200 since we know Rkt won't be compatible above 200 MPa    if  P_MPa[np.size(P_MPa) - 1] > Constants.PminHPices_MPa:        P_initial_upper_MPa = Constants.PminHPices_MPa    # Find the new upper pressure limit, which may be below 200 MPa for frezchem    P_new_upper_MPa = pressure_constraint(P_initial_upper_MPa, aqueous_species_list, speciation_ratio_mol_kg, "frezchem.dat")    # Save the initial lower limit of temperature of the temperature range, which may be adjusted since supcrt can only go to about ~240K depending on solution    T_initial_lower_K = T_K[0]    # If the initial lower limit is below Constants.TminRkt_K (240K) then reset to that value since we know supcrt can't go below this temperature    if T_initial_lower_K < Constants.TminRkt_K:        T_initial_lower_K = Constants.TminRkt_K    # Find the new lower temperature limit, which may be above 240K    T_new_lower_K = temperature_constraint(T_initial_lower_K, aqueous_species_list, speciation_ratio_mol_kg, "supcrt16")    # Adjust the pressure and temperature ranges with the new constraints    newP_MPa, newT_K = ResetNearestExtrap(P_MPa, T_K, P_lower_MPa, P_new_upper_MPa,                                          T_new_lower_K, T_upper_K)    # If the pressure and/or temperature ranges were adjusted, then log that they were changed to the user    if (not np.all(newP_MPa == P_MPa)) or (not np.all(newT_K == T_K)):        log.warning(f'Input EOS P and/or T of [Pmin, Pmax] = {P_lower_MPa}, {P_MPa[np.size(P_MPa) - 1]} MPa and [Tmin, Tmax] = {T_K[0]}, {T_upper_K}\n' +                    'extended beyond the Rkt compatibility limits, which will be adjusted to a compatible range of\n' +                    f'[Pmin, Pmax] = {P_lower_MPa}, {P_new_upper_MPa} MPa and [Tmin, Tmax] = {T_new_lower_K}, {T_upper_K} K.')    # Save only the unique values in the array and return    P_MPa = np.unique(newP_MPa)    T_K = np.unique(newT_K)    return P_MPa, T_Kdef pressure_constraint(P_MPa, aqueous_species_list, speciation_ratio_mol_kg, database, dP = -1):    """ Find the pressure constraint at which Reaktoro can find equilibrium for the given speciation and database. Starts at P_MPa and checks if rkt can find equilibrium        with a temperature of 273K. If it cannot, then adjusts P_MPa by dP and tries again, continuing this process until a compatible P_MPa is found.        If we are looking for upper pressure cosntraint (dP is negative), then we stop also if it reaches <= 1.1 MPa, which Rkt should be compatible with.    Args:        P_MPa: Initial pressure constraint in MPa        aqueous_species_list: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        database: Database to find pressure constraint for        dP: The amount to change P_MPa by if equilibrium is not achieved. Defaults to -1 (for upper constraint)    Returns:        P_MPa: New pressure constraint in MPa for given database.    """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Initilialize the database, either being supcrt of phreeqc    if "supcrt" in database:        db = rkt.SupcrtDatabase(database)        # Since supcrt labels "H2O(aq)", we need to adjust our species list and dictionary accordingly        aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(            aqueous_species_list, speciation_ratio_mol_kg)    else:        db = rkt.PhreeqcDatabase(database)    # Prescribe the solution and solids    solution = rkt.AqueousPhase(aqueous_species_list)    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - pressure and temperature    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.temperature()    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    # Establish equilibrium constraint values    conditions = rkt.EquilibriumConditions(specs)    conditions.temperature(273, "K")    # Tracker variable for equilibrium being found    success = False    # While we have not found chemical equilibrium, keep iterating through    while not success:        conditions.pressure(P_MPa, "MPa")        # Populate the state with the prescribed species at the given ratios        for ion, ratio in speciation_ratio_mol_kg.items():            state.add(ion, ratio, "mol")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Check if the equilibrium problem succeeded        if result.succeeded():            # If so, change success to true            success = True        # To prevent an infinite loop, added this statement which will stop when P_MPa is <= 1.1 and dP < 0, meanign we are looking for upper pressure constraint        elif P_MPa <= 1.1 and dP < 0:            log.debug("Infinite loop prevention stopped for pressure_constraint. Should likely not be occurring")            success = True        # Otherwise, equilibrium is not achieved so we should reset the state and adjust P_MPa by dP, and reattempt the equilibrium problem        else:            state = rkt.ChemicalState(system)            P_MPa += dP    # Return the adjusted P_MPa    return P_MPadef temperature_constraint(T_K, aqueous_species_list, speciation_ratio_mol_kg, database, dT = 1):    """ Find the tempearture constraint at which Reaktoro can find equilibrium for the given speciation and database. Starts at T_K and checks if rkt can find equilibrium        with a pressure of 0.1 MPa. If it cannot, then adjusts T_K by dT and tries again, continuing this process until a compatible T_K is found.        For finding the lower temperature constraint if it reaches >= 273K we stop, which Rkt should be compatible with.    Args:        T_K: Initial temperature constraint in K        aqueous_species_list: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        database: Database to find temperature constraint for        dT: The amount to change T_K by if equilibrium is not achieved. Defaults to 1 (for lower constraint)    Returns:        T_K: New temperature constraint in T_K for given database.    """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Initilialize the database, either being supcrt of phreeqc    if "supcrt" in database:        db = rkt.SupcrtDatabase(database)        # Since supcrt labels "H2O(aq)", we need to adjust our species list and dictionary accordingly        aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(            aqueous_species_list, speciation_ratio_mol_kg)    else:        db = rkt.PhreeqcDatabase(database)    # Prescribe the solution and solids    solution = rkt.AqueousPhase(aqueous_species_list)    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - pressure and temperature    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.temperature()    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    # Establish equilibrium constraint values    conditions = rkt.EquilibriumConditions(specs)    conditions.pressure(0.1, "MPa")    # Tracker variable for equilibrium being found    success = False    # While we have not found chemical equilibrium, keep iterating through    while not success:        conditions.temperature(T_K, "K")        # Populate the state with the prescribed species at the given ratios        for ion, ratio in speciation_ratio_mol_kg.items():            state.add(ion, ratio, "mol")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Check if the equilibrium problem succeeded        if result.succeeded():            # If so, change success to true            success = True        # If it failed but T_K >= 273 and dT > 0, which indicates we are finding lower constraint, then set success to true since RKt should be compatible        elif T_K >= 273 and dT > 0:            log.debug("Infinite loop prevention stopped for temperature_constraint. Should likely not be occurring")            success = True        # Otherwise, equilibrium is not achieved so we should reset the state and adjust T_K by dT, and reattempt the equilibrium problem        else:            T_K += dT            state = rkt.ChemicalState(system)    # Return the adjusted T_K    return T_Kdef RktProps(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K):    """ Determine density rho, heat capacity Cp, thermal expansivity alpha,        and thermal conductivity kTherm as functions of pressure P and        temperature T for the provided solution species list and corresponding molarity ratios.        Implements Reaktoro Supcrt database to find these thermal properties at equilibrium for the prescribed pressure and temperature.        Importantly, if any thermal properties cannot be found due to equilibrium divergence, we perform a 2d linear interpolation on these values, however        this outcome is HIGHLY UNLIKELY since we have found constraints that are compatible with Rkt, and user is warned if this does occur.    Args:        aqueous_species_string: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)        P_MPa (float, shape N): Pressures in MPa        T_K (float, shape M): Temperature in K        Returns:            rho_kgm3 (float, shape NxM): Mass density of liquid in kg/m^3            Cp_JkgK (float, shape NxM): Isobaric heat capacity of liquid in J/(kg K)            alpha_pK (float, shape NxM): Thermal expansivity of liquid in 1/K            kTherm_WmK (float, shape NxM): Thermal conductivity of liquid in W/(m K)    """    # Convert H2O label to H2O(aq) label for compatability with Supcrt database    aqueous_species_list, supcrt_speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(aqueous_species_list, speciation_ratio_mol_kg)    # Create lists of thermodynamic properties that will be of length NxM    rho_kgm3 = []    Cp_JKgK = []    alpha_pK = []    kTherm_WmK = []    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Go through each (P,T) combination, iterating through each P in P_MPa for a T in T_K    # Initilialize the database    db = rkt.SupcrtDatabase("supcrt16")    # Prescribe the solution and solids    solution = rkt.AqueousPhase(aqueous_species_list)    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - pressure and temperature    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.temperature()    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    props = rkt.ChemicalProps(state)    # Establish equilibrium constraint values    conditions = rkt.EquilibriumConditions(specs)    # To increase efficiency, set up the chemical problem before iterating through each P    for T in T_K:        conditions.temperature(T, "K")        # Now that we have created a Reaktoro instance for a given temperature, go through each pressure        for P in P_MPa:            #Establish equilibrium pressure constraint value            conditions.pressure(P, "MPa")            # Populate the state with the prescribed species at the given ratios            for ion, ratio in supcrt_speciation_ratio_mol_kg.items():                state.add(ion, ratio, "mol")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If it did succeed, obtain the relevant aqueous only phase props                aqueous_props = props.phaseProps("AqueousPhase")                # Obtain the thermodynamic properties of the aqueous phase                rho_kg_m3 = aqueous_props.density()                Cp_J_kg_K = aqueous_props.specificHeatCapacityConstP()                # To calculate thermal coefficient, we will multiply inverse of specific volume by its                # partial derivative with respect to temperature                specific_volume_m3_kg = aqueous_props.specificVolume()                dSpecificVolumedT = aqueous_props.specificVolumeT()                thermalExpansivity_1_K = 1 / float(specific_volume_m3_kg) * float(dSpecificVolumedT)                # Append the values to the associated array                rho_kgm3.append(float(rho_kg_m3))                Cp_JKgK.append(float(Cp_J_kg_K))                alpha_pK.append(thermalExpansivity_1_K)                # Reset the state                state = rkt.ChemicalState(system)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            # THIS IS VERY UNLIKELY SINCE WE HAVE ESTABLISHED CONSTRAINTS OF TEMPERATURE AND PRESSURE THAT SHOULD WORK WITH SUPCRT            else:                # Log to the user that the computation was unsuccessful and what is going to happen                log.warning(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, thus we will linearly extrapolate this value from previous ones using a 2d interopolation")                # Reset the state                state = rkt.ChemicalState(system)                # Append zeros for now                rho_kgm3.append(0.0)                Cp_JKgK.append(0.0)                alpha_pK.append(0.0)    # Turn the list into an array and transpose it into a format identical to what PP does, where pressure is in row and temperature is in columns    rho_kgm3 = np.array(rho_kgm3).reshape(len(T_K), len(P_MPa)).T    Cp_JKgK = np.array(Cp_JKgK).reshape(len(T_K), len(P_MPa)).T    alpha_pK = np.array(alpha_pK).reshape(len(T_K), len(P_MPa)).T    # Thermal conductivity not provided by RKT, for now return constant thermal conductivity of water    kTherm_WmK = np.zeros_like(alpha_pK) + Constants.kThermWater_WmK    # In the case that any properties could not be calculated, we must linearly interpolate this    # THIS IS HIGHLY UNLIKELY SINCE WE HAVE FOUND CONSTRAINTS COMPATIBLE WITH RKT, BUT JUST IN CASE THIS IS IMPLEMENTED (has not been rigorously tested)    zero_indices = np.argwhere(rho_kgm3 == 0)    if np.size(zero_indices) != 0:        rho_kg_m3, Cp_JKgK, alpha_pK = interpolation_2d(zero_indices, rho_kg_m3, Cp_JKgK, alpha_pK)    # Return the thermodynamic properties    return rho_kgm3, Cp_JKgK, alpha_pK, kTherm_WmKdef species_convertor_compatible_with_supcrt(aqueous_species_string, speciation_ratio_mol_kg):    """    Converts aqueous species string and speciation ratio dictionary into formats compatible with supcrt. Namely, in phreeqc the liquid phase of H2O    is labeled "H2O", whereas in supcrt it requires "H2O(aq)". Thus, converts "H2O" in the string and speciation ratio dictionary to "H2O(aq)".    Importantly, since speciation_ratio_mol_kg is a dictionary, we must make a deep copy before editing so as to not disturb the original dictionary, which    will still be used by the phreeqc database in the phase change function.    Args:        aqueous_species_string: String that has all species names that should be considered in aqueous phase        speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)    Returns:        aqueous_species_string: Adapted string that has all species names in format compatible with supcrt        supcrt_speciation_ratio_mol_kg: Deep copy of dictionary that has species names in format compatible with supcrt    """    # Check if "H2O" is in the string (and thus dictionary), indicating it is not compatible with supcrt    if "H2O" in aqueous_species_string:        # Change "H2O" to "H2O(aq) in the string        aqueous_species_list = aqueous_species_string.replace("H2O", "H2O(aq)")        # Since python passes dictionary by reference, need to make deep copy to preserve original dictionary        supcrt_speciation_ratio_mol_kg = copy.deepcopy(speciation_ratio_mol_kg)        # Now change the "H2O" key in the dictionary to "H2O(aq)"        supcrt_speciation_ratio_mol_kg["H2O(aq)"] = supcrt_speciation_ratio_mol_kg.pop("H2O")        # Return the string and adapted dictionary        return aqueous_species_list, supcrt_speciation_ratio_mol_kg    else:        # If "H2O" is not in the string (and thus dictionary), then just return them back        return aqueous_species_string, speciation_ratio_mol_kgclass RktPhase:    """    Class that can find the phase of a given speciation over a range of temperatures and pressures    """    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        """        Initialize the RKtPhase() object with the minimum and maximum T (in K) and P (in MPa) and speciation info.        Importantly, find the associated freezing temperature at PMax_MPa, which will be used if any input pressure is >= PMax_MPa, since        Rkt won't be able to solve that problem.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        self.PMax_MPa = PMax_MPa        # Obtain the freezing temperature at PMax - this will drasticaslly decrease runtime when this object is called since        # rkt_t_freeze won't have to be called each time        self.TFreezing_At_PMax = rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, self.PMax_MPa, TMin_K, TMax_K, "frezchem.dat")    def __call__(self, P_MPa, T_K, grid = False):        """        Call the ice_freezing function for the given input P_MPa and T_K coordinates.        Importantly, ice_frrezing assumes P_MPa and T_K are the same size and correspond to one another (coordinate pairs),        so we get them into that format if they are not already.        Args:            P_MPa: Array of pressures            T_K: Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            The associated phases of the solution for the input pressure and temperatures        """        # Convert a 0-d numpy array (only holds one value) into a 1d array so it is compatible with ice_freezing function        if np.size(P_MPa) == 1:            P_MPa = np.atleast_1d(P_MPa)        if np.size(T_K) == 1:            T_K = np.atleast_1d(T_K)        # SHOULD ADD GRID IMPLEMENTATION HERE        # Similar approach to SF, where we specify the P_MPa and T_K at equilibrium, and ice_freezing function returns        # if ice has formed or not at given temperature and pressure, with 1 indicating the phase is solid and 0 indicating the phase is liquid        return ice_freezing(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, T_K, self.PMax_MPa, self.TMin_K, self.TMax_K, self.TFreezing_At_PMax).astype(np.int_)        # Alternative used approaches that did not work are listed below (CAN BE DELETED IN FUTURE)        '''        # IDENTICAL APPROACH TO GSW        # 1. Subtract the freezing temperature from the input temperature        # 2. Compare to zero -- if we are below the freezing temp, it's ice I, above, liquid        # 3. Cast the above comparison (True if less than Tfreeze, False if greater) to int,        #       so that we get 1 if we are below the freezing temp and 0 if above.        return (T_K - rkt_t_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, self.TMin_K,                            self.TMax_K) < 0).astype(np.int_)        Alternative approach is to obtain Pfreezing from the prescribed T_K, since the way PlanetProfile obtains the Melting EOS,        this class will not have access to the hydrosphere TMin and TMax which I am using to constrain Reaktoro's search.        Instead, can use the constraints of         PMin to PMax to find the freezing pressure for a prescribed temperature via Reaktoro.        return (P_MPa - rkt_p_freeze(self.aqueous_species_list, self.speciation_ratio_mol_kg, T_K, self.PMin_MPa,                            self.PMax_MPa) < 0).astype(np.int_)        '''def SpeciesParser(species_string_with_ratios):    '''    Converts the provided String of species and their molar ratios into formats necessary for Reaktoro. Namely, creates    a String of all the species in the list and a dictionary with 'active' species that are added to solution (the observer species are    automatically generated to be 1e-16 moles in the solution by Reaktoro). It also returns the w_ppt of the solution. If any of the species do not exist in the database Reaktoro is implementing    (namely frezchem), this method raises an error that the species does not exist.     Parameters     ----------     species_string_with_ratios: String of all the species that should be considered in aqueous phase and their corresponding molar ratios.        For example, "Cl-: 19.076, Na+: 5.002, Ca2+: 0.0"     Returns     -------     aqueous_species_string: String that has all species names that should be considered in aqueous phase     speciation_ratio_mol_kg: Dictionary of active species and the values of their molar ratio (mol/kg of water)    '''    db = rkt.PhreeqcDatabase("frezchem.dat")    aqueous_species_string = ""    speciation_ratio_mol_kg = {}    # Go through each species and corresponding ratio_mol_kg and add to corresponding lists    for species_with_ratio in species_string_with_ratios.split(", "):        species, ratio_mol_kg = species_with_ratio.split(": ")        # Ensure that species is in frezchem database and if not then raise error        try:            db.species(species)        except:            raise ValueError(f'{species} does not exist in the frezchem database. Check that it is spelled correctly')        aqueous_species_string = aqueous_species_string + species + " "        # Check if the species is active (amount > 0 mol) and if so, add it to the dictionary        if (float(ratio_mol_kg) > 0):            speciation_ratio_mol_kg[species] = float(ratio_mol_kg)    # Check if water is in the aqueous species string and dictionary and if not, add it, ensuring to update the weight to be 1kg    if not "H2O" in aqueous_species_string:        aqueous_species_string = aqueous_species_string + "H2O "    speciation_ratio_mol_kg.update({"H2O": float(1/rkt.waterMolarMass)}) #Adds mols of H2O for 1kg of total solution    # Return the species string and dictionary (remove the trailing white space from the String as well with rstrip())    return aqueous_species_string.rstrip(" "), speciation_ratio_mol_kgdef ice_freezing(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K, PMax_MPa, TMin_K, TMax_K, TFreezing_At_PMax, significant_threshold = 1e-14):    """     Calculates whether ice is freezing at the given temperature and pressure. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure and temperature with the given composition,     and determines if ice has formed at a significant threshold of 1e-14, therefore calculating the phase of the solution     and returning true if the phase is ice and false if the phase is liquid.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.     T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     ice_present (boolean, shape N): an array of true and falses that indicate whether for prescribed P_MPa and T_K coordiantes        if there is ice present at significant threshold (default of 1e-14)     """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create list that holds boolean values of whether ice is present    ice_present = []    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for i in range(np.size(P_MPa)):        P = P_MPa[i]       # Ensure that the pressure is below 100MPa, the maximum pressure that Phreeqc can handle        if P < PMax_MPa:            # Obtain associated temperature            T = T_K[i]            # Obtain the corresponding database (either frezchem or core10, depending on the temperature)            database = ""            ice_name = ""            if 200 < T and T < 298.15:                database = "frezchem.dat"  # Frezchem is compatible from 200 to 298.15K                ice_name = "Ice(s)"            else:                database = "core10.dat"                ice_name = "Ice"            # Initialize the database            db = rkt.PhreeqcDatabase(database)            # Prescribe the solution            solution = rkt.AqueousPhase(aqueous_species_list)            # Obtain all related solid phases            solids = rkt.MineralPhases()            # Initialize the system            system = rkt.ChemicalSystem(db, solution, solids)            # Create constraints on equilibrium - pressure and temperature            specs = rkt.EquilibriumSpecs(system)            specs.pressure()            specs.temperature()            # Create a solver object            solver = rkt.EquilibriumSolver(specs)            # Create a chemical state and its associated properties            state = rkt.ChemicalState(system)            props = rkt.ChemicalProps(state)            conditions = rkt.EquilibriumConditions(specs)            conditions.pressure(P, "MPa")            conditions.temperature(T, "K")            # Populate the state with the prescribed species at the given ratios            for ion, ratio in speciation_ratio_mol_kg.items():                state.add(ion, ratio, "mol")            # Solve the equilibrium problem            result = solver.solve(state, conditions)            # Update the properties            props.update(state)            # Check if the equilibrium problem succeeded            if result.succeeded():                # If so, obtain the total amount of solid H2O at equilibrium in moles                ice_amount = props.speciesAmount(ice_name)                # If the amount of solid H2O at equilibrium is > the significant threshold, then append true to the list, otherwise append false                ice_present.append(ice_amount > significant_threshold)                # Reset the state                state = rkt.ChemicalState(system)            # Otherwise, the equilibrium problem failed so we need to handle it accordingly            else:                # Warn the user about the failed equilibrium (good for debugging)                log.debug(                    f"Unsuccessful computation at: {props.pressure() / 1e+6} MPa and {props.temperature()} K.\n"                    f"The temperature and pressure may be out of bounds, but sometimes Reaktoro fails to converge on specific values even within bounds.\n"                    f"Will take an alternative approach of rerunning the equilibrium calculation by determining the temperature at which ice begins to forms at the given pressure and composition,\n"                    f"and if this temperature is below the freezing temperature then we will assume the state is solid, and if the temperature is above the freezing temperature then we will assume the state is liquid.")                # Instead, we will find the associated freezing temperature with the prescribed pressure and compare that freezing temperature to T                freezing_temperature = rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P, TMin_K, TMax_K, database, significant_threshold)                # If T is <= the freezing temperature for the given pressure, then we will assume ice is also present at this temperature and append True to list                # Otherwise, if T > the freezing temperature, we will assume ice is not present and append False to list                ice_present.append(T <= freezing_temperature) # If T <= freezing_temperature, then we assume ice is present                # Reset the state                state = rkt.ChemicalState(system)        # If Pressure is >= PMax, Reaktoro is at its limits of computation and will likely fail. Thus, we can compare T_K[i] to        # the freezing temperature at P_Max, which we have already saved. This alternative approach will yield good results in addition to        # drastically improving runtime by not needing to create a Reaktoro object each instance that PMax is reached.        else:            ice_present.append(T_K[i] < TFreezing_At_PMax)    # Convert the ice_present list into an array (of shape N) and return    ice_present = np.array(ice_present)    return ice_presentdef ices_phases_amount_mol(props: rkt.ChemicalProps):    '''    Helper equilibirum constraint function to constrain the total amount of moles of all ices in the current state using its associated properties. Function is used in    the ice constraint for rkt_p_freeze().    '''    # Get name of H2O ice (either Ice(s) for frezchem or Ice for core10.dat)    ice_name = ""    try:        # Check if ice is labeled as "Ice(s)" in database (core10.dat labeling)        props.system().database().species("Ice(s)")        ice_name = "Ice(s)"    except Exception as e:        # If exception is thrown, then we are using frezchem.dat database and ice_name should be "Ice"        ice_name = "Ice"    # Return the amount of solid H2O in the state, given by moles    return props.speciesAmount(ice_name)def rkt_t_freeze(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, TMin_K, TMax_K, database, signifant_threshold = 1e-14):    """     Calculates the temperature at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to     constrain the equilibrium position at the prescribed pressure, the lower and upper limits of temperature (in MPa),     and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the     temperature (within the range) at which ice begins to form.     Parameters     ----------     aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species     speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary     with the species as the key and its ratio as its value.     P_MPa: the desired equilibrium freezing pressure(s).     TMin_K: the lower limit of temperature that Reaktoro should query over     TMax_K: the upper limit of temperature that Reaktoro should query over     database: the Phreeqc database to be using in this calculation (either frezchem.dat or core10.dat)     significant_threshold: the amount of moles of ice present for H2O to be considered in solid phase. Default is 1e-14 moles.     Returns     -------     t_freezing_K: the temperature at which the solution begins to freeze.     """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Expand the TMin and TMax boundaries slightly to ensure that Reaktoro can find a freezing temperature associated with given pressure.    TMax_K += 30    TMin_K -= 30    # Initialize the database with the corersponding database    db = rkt.PhreeqcDatabase(database)    # Prescribe the solution    solution = rkt.AqueousPhase(aqueous_species_list)    # Obtain all related solid phases    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium and establish that temperature is unknown    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.unknownTemperature()    # Create equilibrium constraint on the phase amount of ices to significant threshold    # This constraint will allow Reaktoro to query for the pressure at which ice begins to form at the prescribed pressure    idx_ice_phase = specs.addInput("IP")    ices_phase_constraint = rkt.EquationConstraint()    ices_phase_constraint.id = "icePhaseAmountConstraint"    ices_phase_constraint.fn = lambda props, w: ices_phases_amount_mol(props) - w[idx_ice_phase]    specs.addConstraint(ices_phase_constraint)    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    props = rkt.ChemicalProps(state)    # Prescribe the equilibrium constraints on pressure at P_MPa, ice phase amount at the significant threshold,    # and the temperatures to query over    conditions = rkt.EquilibriumConditions(specs)    conditions.pressure(P_MPa, "MPa")    conditions.set("IP", signifant_threshold)    conditions.setLowerBoundTemperature(TMin_K, "K")    conditions.setUpperBoundTemperature(TMax_K, "K")    # Populate the state with the prescribed species at the given ratios    for ion, ratio in speciation_ratio_mol_kg.items():        state.add(ion, ratio, "mol")    # Solve the equilibrium problem    result = solver.solve(state, conditions)    # Update the properties    props.update(state)    # Obtain the equilibrium temperature    equilibrium_temperature = props.temperature()    # Check if the result succeeded    if result.succeeded():        log.debug(f"Successfully found a bottom freezing temperature of {equilibrium_temperature} K for the pressure of {P_MPa} MPa.")    # If the result failed, reaktoro gets as close as possible to freezing temperature for given pressure so we will utilize this. However, warn this to the user    else:        log.warning(f"While attempting to find bottom freezing temperature for pressure of {P_MPa} MPa, \n"                    +f"Reaktoro was unable to find a temperature within range of {TMin_K} K and {TMax_K}.\n"                    +f"Reaktoro gets as close as possible to a freezing temperature within range, which it found to be {equilibrium_temperature} so we will use this value.")    # Return the equilibrium temperature    return equilibrium_temperatureclass RktSeismic():    def __init__(self, aqueous_species_list, speciation_ratio_mol_kg, TMin_K, TMax_K, PMin_MPa, PMax_MPa):        """        Initialize the RKtSeismic() object with the minimum and maximum T (in K) and P (in MPa) and speciation info.        """        self.aqueous_species_list = aqueous_species_list        self.speciation_ratio_mol_kg = speciation_ratio_mol_kg        self.TMin_K = TMin_K        self.TMax_K = TMax_K        self.PMin_MPa = PMin_MPa        self.PMax_MPa = PMax_MPa    def __call__(self, P_MPa, T_K, grid = False):        """        Finds the sound speed in km/s and bulk modulus in GPa for the input of P_MPa and T_K        Args:            P_MPa (float, Shape N): Array of pressures            T_K (float, Shape N): Array of temperatures            grid: Whether or not they need to be made into a coordinate grid        Returns:            VP_kms (float, Shape N): Corresponding sound speeds in km/s            KS_GPa (float, Shape N): Corresponding bulk modulus in GPa        """        # Convert a 0-d numpy array (only holds one value) into a 1d array so it is compatible with ice_freezing function        if np.size(P_MPa) == 1:            P_MPa = np.atleast_1d(P_MPa)        if np.size(T_K) == 1:            T_K = np.atleast_1d(T_K)        # Finds the sound speed and associated densities for the given pressure and temperature inputs        VP_kms, rho_kgm3 = seismic_calculations(self.aqueous_species_list, self.speciation_ratio_mol_kg, P_MPa, T_K)        # Calculates the bulk modulus from its relaiontship with sound speed and density        KS_GPa = rho_kgm3 * VP_kms**2*1e-3 # 1e-3 because (km/s)^2 * (kg/m^3) gives units of MPa, so 1e-3 to convert to GPa        # Return sound speed and bulk modulus        return VP_kms, KS_GPadef seismic_calculations(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K):    """    Calculates the sound speed and densities of the aqueous phase of the solution for the input pressure and temperatures,    utilizing the thermodynamic properties provided by the supcrt database at equilibrium.    Args:        aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species        speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary with the species as the key and its ratio as its value.        P_MPa (float, shape N): the desired equilibrium freezing pressure(s) in an array of size N.        T_K (float, shape N): the desired equilibrium freezing temperature(s) in an array of size N.    Returns:        sound_speeds (float, shape N): Associated aqueous sound speeds in km/s        densities (float, shape N): Associated aqueous densities in km/s    """    # Convert H2O label to H2O(aq) label for compatability with Supcrt database    aqueous_species_list, speciation_ratio_mol_kg = species_convertor_compatible_with_supcrt(        aqueous_species_list, speciation_ratio_mol_kg)    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Create list that will become array that will hold sound speeds    sound_speeds = []    # Create list that will become array taht holds corresponding aqueous densities    densities = []    # Create Reaktoro objects    # Initilialize the database    db = rkt.SupcrtDatabase("supcrt16")    # Prescribe the solution and solids    solution = rkt.AqueousPhase(aqueous_species_list)    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - pressure and temperature    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.temperature()    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    props = rkt.ChemicalProps(state)    # Establish equilibrium constraint values    conditions = rkt.EquilibriumConditions(specs)    # Go through each (P,T) combination, where we assume that P_MPa and T_K are same size and correspond to one another    for i in range(np.size(P_MPa)):        P = P_MPa[i]        T = T_K[i]        conditions.temperature(T, "K")        conditions.pressure(P, "MPa")        # Populate the state with the prescribed species at the given ratios        for ion, ratio in speciation_ratio_mol_kg.items():            state.add(ion, ratio, "mol")        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the equilibrium problem succeeded        if result.succeeded():            # If it did succeed, obtain the relevant aqueous only phase props            aqueous_props = props.phaseProps("AqueousPhase")            # Obtain density, specific volume, and pressure derivative of specific volume            density_kg_m3 = float(aqueous_props.density())            specific_volume_m3_kg = float(aqueous_props.specificVolume())            pressure_derivative_specific_volume = float(aqueous_props.specificVolumeP())            # Calculate commpressibility factor, multiplying negative inverse of specific volume by pressure derivative of specific volume            k_compressibility = -(1/specific_volume_m3_kg)*pressure_derivative_specific_volume            # Calculate sound speed, multiplying k by density and taking the product to the -0.5            c_m_s = (density_kg_m3*k_compressibility)**(-0.5)            # Convert to km/s            c_km_s = c_m_s / 1000            # Append to lists            sound_speeds.append(c_km_s)            densities.append(density_kg_m3)            # Reset the state            state = rkt.ChemicalState(system)        # If equilibrium did not succeed, then we will linearly interpolate these values        # THIS IS VERY UNLIKELY SINCE WE ARE CALCULATING SEISMIC VALUES FOR OCEAN LAYER WHICH HAS ALREADY BEEN CALCULATED BY RKT, SO VALUES SHOULD BE WITHIN RANGE OF RKT        else:            # For now, just append zero and we will handle later            sound_speeds.append(0.0)            densities.append(0.0)            # Reset the state            state = rkt.ChemicalState(system)    # Convert lists to arrays    sound_speeds = np.array(sound_speeds)    densities = np.array(densities)    # Check if any values are zero, which indicates they were not found in chemcial equilibrium    # THIS IS VERY UNLIKELY SINCE RKT SHOULD BE ABLE TO HANDLE INPUT P AND T RANGE, HOWEVER FOR SELF-CONSISTENCY WE ADD THIS IN CASE    zero_indices = np.argwhere(densities == 0)    if np.size(zero_indices) != 0:        rho_kg_m3, Cp_JKgK, alpha_pK = interpolation_2d(zero_indices, rho_kg_m3, Cp_JKgK, alpha_pK)    return sound_speeds, densitiesdef interpolation_2d(zero_indices, rho_kgm3, Cp_JKgK, alpha_pK):    """ Utilized as a helper function for thermodynamic properties calculation. Performs a 2d interpolation on any values that are non-zero in the        provided arrays, allowing the zero values to be interpolated.    Args:        zero_indices: Array of indices where there are zeros        rho_kgm3 (float, shape NxM): Mass density of liquid in kg/m^3        Cp_JkgK (float, shape NxM): Isobaric heat capacity of liquid in J/(kg K)        alpha_pK (float, shape NxM): Thermal expansivity of liquid in 1/K    Returns:        rho_kgm3 (float, shape NxM): Mass density of liquid in kg/m^3 whose zero values have been replaced by interpolated values        Cp_JkgK (float, shape NxM): Isobaric heat capacity of liquid in J/(kg K) whose zero values have been replaced by interpolated values        alpha_pK (float, shape NxM): Thermal expansivity of liquid in 1/K whose zero values have been replaced by interpolated values    """    array_lists = [rho_kgm3, Cp_JKgK, alpha_pK]    for array in array_lists:        # Create mask of non-zero values        nonzero_mask = (array != 0)        # Interpolate using scipy interp2d function        x, y = np.meshgrid(np.arange(array.shape[1]), np.arange(array.shape[0]))        x_interp = x[nonzero_mask]        y_interp = y[nonzero_mask]        z_interp = array[nonzero_mask]        f = interpolate.interp2d(x_interp, y_interp, z_interp, z_interp, kind='linear')        for idx in zero_indices:            if array[idx[0], idx[1]] == 0:                array[idx[0], idx[1]] = f(idx[1], idx[0])    log.warning("Performed 2d linear interpolation on missing thermodynamic properties")    return rho_kgm3, Cp_JKgK, alpha_pKdef interpolation_1d(zero_indices, array1, array2):    array_lists = [array1, array2]    for array in array_lists:        # Create mask of non-zero values        nonzero_mask = (array != 0)        # Interpolate using scipy interp2d function        x_interp = np.arange(len(array))        x_interp_nonzero = x_interp[nonzero_mask]        y_interp_nonzero = array[nonzero_mask]        f = interpolate.interp1d(x_interp_nonzero, y_interp_nonzero, kind = 'linear', fill_value = 'extrapolate')        for idx in zero_indices:            if array[idx] == 0:                array[idx] = f(idx)    log.warning("Performed 1d linear interpolation on missing seoismic properties")    return array1, array2# -----------------------------------# Functions below are not utilized, but may be useful at some point in future# -----------------------------------def rkt_p_freeze(aqueous_species_list, speciation_ratio_mol_kg, T_K, PLower_MPa, PUpper_MPa):    """    Calculates the pressure at which the prescribed aqueous solution freezes. Utilizes the reaktoro framework to    constrain the equilibrium position at the prescribed T_K, the lower and upper limits of pressure (in MPa),    and the total amount of ice at a significant threshold of 1e-14, therefore calculating and returning the    pressure (within the range) at which ice begins to form.    Parameters    ----------    aqueous_species_list: aqueous species in reaction. Should be formatted in one long string with a space in between each species    speciation_ratio_mol_kg: the ratio of species in the aqueous solution in mol/kg of water. Should be a dictionary    with the species as the key and its ratio as its value.    T_freezing_K: the desired equilibrium freezing temperature    PLower_MPa: the lower limit of pressure that Reaktoro should query over    PUpper_MPa: the upper limit of pressure that Reaktoro should query over    Returns    -------    p_freezing_MPa: the pressure at which the solution begins to freeze    """    # Initilialize the database with frezchem    db = rkt.PhreeqcDatabase("frezchem.dat")    # Prescribe the solution    solution = rkt.AqueousPhase(aqueous_species_list)    # Obtain all related solid phases    solids = rkt.MineralPhases("Ice(s)")    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - temperature and significant threshold for ice    specs = rkt.EquilibriumSpecs(system)    specs.temperature()    # Create equilibrium constraint on the phase amount of ices to 1e-14    # This constraint will allow Reaktoro to query for the pressure at which ice begins to form at the prescribed temperature    ice_phase_final = 1e-14 # Establish the desired equilibrium amount of total ices (1e-14 moles)    idx_ice_phase = specs.addInput("IP")    ices_phase_constraint = rkt.EquationConstraint()    ices_phase_constraint.id = "icePhaseAmountConstraint"    ices_phase_constraint.fn = lambda props, w: ices_phases_amount_mol(props) - w[idx_ice_phase]    specs.addConstraint(ices_phase_constraint)    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state and its associated properties    state = rkt.ChemicalState(system)    props = rkt.ChemicalProps(state)    # Check if pressure is a list and if so, then query over each pressure and obtain the associated bottom temperature    p_freezing_MPa = []    # Use a for loop to go through each temperature    for temperature in T_K:        # Prescribe the equilibrium constraints on temperature at T_K, ice phase amount at the significant threshold,        # and the pressures to query over        conditions = rkt.EquilibriumConditions(specs)        conditions.temperature(temperature, "K")        conditions.set("IP", ice_phase_final)        conditions.setLowerBoundPressure(PLower_MPa, "MPa")        conditions.setUpperBoundPressure(PUpper_MPa, "MPa")        # Populate the state with the prescribed species at the given ratios        for ion, ratio in speciation_ratio_mol_kg.items():            state.add(ion, ratio, "mol")        # Add a kg of water to the state        # Solve the equilibrium problem        result = solver.solve(state, conditions)        # Update the properties        props.update(state)        # Check if the result failed, and if it did, then it is likely because the freezing pressure could not be found given the pressure constraints.        # Thus, check if the state has reached the pressure limits so append the constraint and add this        if result.failed():            # Check if we have reached the upper pressure constraint            if props.pressure() == PUpper_MPa:                print("Have reached the upper pressure constraint of ", props.pressure, "MPa. Consider raising PMax_MPa")            print("Returning zero as the bottom pressure. Should be handled accordingly.")            p_freezing_MPa.append(np.float_(0))            # Reset the state            state = rkt.ChemicalState(system)        else:            # Otherwise, return the equilibrium state's pressure, which is the bottom pressure (converted to MPa from Pa)            equilibrium_pressure = props.pressure() / 1e+6            print(f"{equilibrium_pressure}MPa at {temperature} K")            p_freezing_MPa.append(equilibrium_pressure)            # Reset the state            state = rkt.ChemicalState(system)    # Convert the p_temperature_K list into an array and return    p_freezing_MPa = np.array(p_freezing_MPa)    return p_freezing_MPadef lowest_temperature_allowed(aqueous_species_list, speciation_ratio_mol_kg, P_MPa, T_K):    """ Find the lowest temperature at which Rkt can find equilibrium.    Args:        aqueous_species_list:        speciation_ratio_mol_kg:        P_MPa:        T_K:    Returns:    """    # Disable chemical convergence warnings that Reaktoro raises. We handle these internally instead and throw more specific warnings when they appear.    rkt.Warnings.disable(906)    # Go through each (P,T) combination, iterating through each P in P_MPa for a T in T_K    # To increase efficiency, set up the chemical problem before iterating through each P    # Initilialize the database    db = rkt.SupcrtDatabase("supcrt16")    # Prescribe the solution and solids    solution = rkt.AqueousPhase(aqueous_species_list)    solids = rkt.MineralPhases()    # Initialize the system    system = rkt.ChemicalSystem(db, solution, solids)    # Create constraints on equilibrium - pressure and temperature    specs = rkt.EquilibriumSpecs(system)    specs.pressure()    specs.temperature()    # Create a solver object    solver = rkt.EquilibriumSolver(specs)    # Create a chemical state    state = rkt.ChemicalState(system)    for ion, ratio in speciation_ratio_mol_kg.items():        state.add(ion, ratio, "mol")    # Establish equilibrium constraint values    conditions = rkt.EquilibriumConditions(specs)    conditions.temperature(T_K, "K")    conditions.pressure(P_MPa, "MPa")    # Solve the equilibrium problem    result = solver.solve(state, conditions)    # If result succeeded, return true, otherwise returnt false    if result.succeeded():        return 0.5    else:        return -0.5def database_to_use(T_K):    """ Decides between frezchem.dat and core10.dat database to use according to the temperature.        As per Comparison of thermodynamic data files for PHREEQC (Lu et. al 2022):            frezchem.dat: 7325C at 1 bar            core10.dat: 0.01100C at 1bar, 100300C along P_Sat (water vapor saturation pressure)        Currently, frezchem will be utilized for 200K<T<298.15T, and dat10 for T>=298.15.    Args:        T_K: The temperature to determine between frezchem.dat and core10.dat    Returns:        database: the database to use according to the temperature criteria above        ice_name: the name of H2O solid state for the database, which has different labels for the databases.    """    if 200 < T_K and T_K < 298.15:        database = "frezchem.dat"  # Frezchem is compatible from 200 to 298.15K        ice_name = "Ice(s)"    else:        database = "core10.dat"        ice_name = "Ice"    return database, ice_name